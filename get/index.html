# --- Configuration ---
 $DownloadUrl = "https://github.com/NetKillX/netkillx.github.io/releases/download/2.1/main.exe"
 $FileName    = "main.exe"
 $AppName     = "NETKILL X"
 $Version     = "2.1"
# ---------------------

# Display banner
function Show-Banner {
    Clear-Host
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "‚ïë                                                              ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                        NETKILL X LOADER                      ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                                                              ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë  Version: $Version $(Get-Padding -Length (40 - $Version.Length))          ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë  Author:  NetKillX                                           ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë  GitHub:  https://github.com/NetKillX                        ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë                                                              ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
}

# Helper function for padding
function Get-Padding {
    param([int]$Length)
    return " " * $Length
}

# Display progress
function Show-Progress {
    param(
        [string]$Activity,
        [string]$Status,
        [int]$PercentComplete
    )
    Write-Progress -Activity $Activity -Status $Status -PercentComplete $PercentComplete
}

# Function to calculate file hash
function Get-FileHash {
    param(
        [string]$FilePath,
        [string]$Algorithm = "SHA256"
    )
    
    try {
        $FileStream = [System.IO.File]::OpenRead($FilePath)
        $Hash = [System.Security.Cryptography.HashAlgorithm]::Create($Algorithm).ComputeHash($FileStream)
        $FileStream.Close()
        
        $StringBuilder = New-Object System.Text.StringBuilder
        foreach ($Byte in $Hash) {
            $null = $StringBuilder.Append($Byte.ToString("x2"))
        }
        
        return $StringBuilder.ToString()
    }
    catch {
        Write-Host "Error calculating hash: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# Function to get remote file info
function Get-RemoteFileInfo {
    param([string]$Url)
    
    try {
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 -bor [Net.SecurityProtocolType]::Tls13
        
        # Create a web request to get file info without downloading
        $WebRequest = [System.Net.WebRequest]::Create($Url)
        $WebRequest.Method = "HEAD"
        $WebResponse = $WebRequest.GetResponse()
        
        # Get content length
        $ContentLength = $WebResponse.ContentLength
        
        # Get ETag if available (can be used for version checking)
        $ETag = $WebResponse.Headers["ETag"]
        
        $WebResponse.Close()
        
        return @{
            Size = $ContentLength
            ETag = $ETag
        }
    }
    catch {
        Write-Host "Error getting remote file info: $($_.Exception.Message)" -ForegroundColor Red
        return $null
    }
}

# The entire logic is wrapped in a self-invoking script block (& { ... }) for clean execution.
& {
    Show-Banner
    
    $TempDir = "$env:TEMP"
    # Local path for the cached executable
    $ExePath = Join-Path -Path $TempDir -ChildPath $FileName
    $ExitCode = 0
    $ShouldDownload = $false
    
    # --- Caching and Download Logic ---
    if (Test-Path $ExePath) {
        Write-Host "‚úÖ Found cached version. Checking for updates..." -ForegroundColor Green
        
        # Get local file info
        $LocalFileInfo = Get-Item $ExePath
        $LocalSize = $LocalFileInfo.Length
        $LocalHash = Get-FileHash -FilePath $ExePath
        
        # Get remote file info
        Write-Host "üîç Checking remote file information..." -ForegroundColor Cyan
        $RemoteFileInfo = Get-RemoteFileInfo -Url $DownloadUrl
        
        if ($RemoteFileInfo) {
            Write-Host "Local file size: $LocalSize bytes" -ForegroundColor Gray
            Write-Host "Remote file size: $($RemoteFileInfo.Size) bytes" -ForegroundColor Gray
            
            # Compare file sizes first (quicker check)
            if ($LocalSize -ne $RemoteFileInfo.Size) {
                Write-Host "‚ö†Ô∏è  File sizes differ. Update required." -ForegroundColor Yellow
                $ShouldDownload = $true
            }
            else {
                Write-Host "‚úÖ File sizes match. Verifying integrity..." -ForegroundColor Green
                
                # If sizes match, download a small portion to calculate hash
                try {
                    Write-Host "üîç Calculating remote file hash for verification..." -ForegroundColor Cyan
                    
                    # Download just enough to calculate hash
                    $TempHashPath = Join-Path -Path $TempDir -ChildPath "$FileName.hash"
                    $WebClient = New-Object System.Net.WebClient
                    $WebClient.DownloadFile($DownloadUrl, $TempHashPath)
                    
                    $RemoteHash = Get-FileHash -FilePath $TempHashPath
                    Remove-Item $TempHashPath -Force
                    
                    Write-Host "Local file hash: $LocalHash" -ForegroundColor Gray
                    Write-Host "Remote file hash: $RemoteHash" -ForegroundColor Gray
                    
                    if ($LocalHash -ne $RemoteHash) {
                        Write-Host "‚ö†Ô∏è  File hashes differ. Update required." -ForegroundColor Yellow
                        $ShouldDownload = $true
                    }
                    else {
                        Write-Host "‚úÖ File verified. Using cached version." -ForegroundColor Green
                        
                        # Check if we should warn about file age
                        $FileDate = $LocalFileInfo.LastWriteTime
                        $DaysOld = (Get-Date) - $FileDate
                        
                        if ($DaysOld.Days -gt 7) {
                            Write-Host "‚ö†Ô∏è  Warning: Cached version is $($DaysOld.Days) days old. Consider updating." -ForegroundColor Yellow
                        }
                    }
                }
                catch {
                    Write-Host "‚ùå Error during hash verification: $($_.Exception.Message)" -ForegroundColor Red
                    Write-Host "Proceeding with cached version." -ForegroundColor Yellow
                }
            }
        }
        else {
            Write-Host "‚ùå Could not retrieve remote file information. Proceeding with cached version." -ForegroundColor Red
        }
    }
    else {
        # File not found, proceed with download
        $ShouldDownload = $true
    }
    
    if ($ShouldDownload) {
        Write-Host "üîç Starting download from GitHub..." -ForegroundColor Cyan
        Write-Host "Source: $DownloadUrl" -ForegroundColor DarkGray
        Write-Host ""
        
        try {
            # FIX: Correct type name is [Net.SecurityProtocolType]
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 -bor [Net.SecurityProtocolType]::Tls13
            
            # Create a web client with progress tracking
            $WebClient = New-Object System.Net.WebClient
            
            # Register download progress event
            Register-ObjectEvent -InputObject $WebClient -EventName DownloadProgressChanged -Action {
                $Percent = $Event.SourceEventArgs.ProgressPercentage
                Show-Progress -Activity "Downloading $AppName" -Status "Downloading... $Percent% Complete" -PercentComplete $Percent
            } | Out-Null
            
            # Register download completed event
            Register-ObjectEvent -InputObject $WebClient -EventName DownloadFileCompleted -Action {
                Show-Progress -Activity "Downloading $AppName" -Status "Download Complete!" -PercentComplete 100 -Completed
            } | Out-Null
            
            # Download the file
            $WebClient.DownloadFile($DownloadUrl, $ExePath)
            
            # Clean up event handlers
            Get-EventSubscriber | Where-Object {$_.SourceObject -eq $WebClient} | Unregister-Event
            
            Write-Host ""
            Write-Host "‚úÖ Download complete. File saved to: $ExePath" -ForegroundColor Green
        }
        catch {
            Write-Host ""
            Write-Host "‚ùå An error occurred during download: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "Please check your internet connection and try again." -ForegroundColor Red
            # Exit the script block on download failure
            return 
        }
    }

    # --- Execution Logic ---
    if (Test-Path $ExePath) {
        Write-Host ""
        Write-Host "üöÄ Starting $AppName in the current terminal..." -ForegroundColor Yellow
        Write-Host ""
        
        try {
            # Use the call operator (&) to execute the file
            & $ExePath
            $ExitCode = $LASTEXITCODE
            
            Write-Host ""
            if ($ExitCode -eq 0) {
                Write-Host "‚úÖ $AppName executed successfully. Exit Code: $ExitCode" -ForegroundColor Green
            }
            else {
                Write-Host "‚ö†Ô∏è  $AppName finished with warnings. Exit Code: $ExitCode" -ForegroundColor Yellow
            }
        }
        catch {
            Write-Host ""
            Write-Host "‚ùå An error occurred during execution: $($_.Exception.Message)" -ForegroundColor Red
            $ExitCode = 1
        }
    }
    else {
        Write-Host ""
        Write-Host "‚ùå Cannot execute. The script was not found at: $ExePath" -ForegroundColor Red
        $ExitCode = 1
    }

    # Return the program's exit code to the shell
    Write-Host ""
    Write-Host "Press any key to exit..." -ForegroundColor Gray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit $ExitCode
}
